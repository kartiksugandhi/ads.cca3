#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ALPHA 26

// A simple hash‐map implementation using chaining (for simplicity here)
typedef struct Node {
    char *key;
    int count;
    struct Node *next;
} Node;

#define MAP_SIZE 100003  // a large prime for hash table size

Node* map_table[MAP_SIZE];

// Simple string hash (djb2)
unsigned long hash_string(const char *str) {
    unsigned long hash = 5381;
    int c;
    while ((c = *str++))
        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
    return hash % MAP_SIZE;
}

Node *map_find(const char *key) {
    unsigned long h = hash_string(key);
    Node *node = map_table[h];
    while (node) {
        if (strcmp(node->key, key) == 0) return node;
        node = node->next;
    }
    return NULL;
}

void map_increment(const char *key) {
    unsigned long h = hash_string(key);
    Node *node = map_table[h];
    while (node) {
        if (strcmp(node->key, key) == 0) {
            node->count++;
            return;
        }
        node = node->next;
    }
    // not found, create
    node = malloc(sizeof(Node));
    node->key = strdup(key);
    node->count = 1;
    node->next = map_table[h];
    map_table[h] = node;
}

long long sherlockAndAnagrams(const char *s) {
    int n = strlen(s);
    int i, j;
    long long result = 0;

    // Clear map
    for (i = 0; i < MAP_SIZE; i++) map_table[i] = NULL;

    // For every possible substring s[i..j]
    for (i = 0; i < n; i++) {
        int freq[ALPHA] = {0};
        for (j = i; j < n; j++) {
            freq[s[j] - 'a']++;
            // Build a key string representing this freq vector
            // e.g. "0#1#0#2#…"
            char key[ALPHA * 4 + 1];
            char *p = key;
            for (int k = 0; k < ALPHA; k++) {
                p += sprintf(p, "%d#", freq[k]);
            }
            *p = '\0';
            map_increment(key);
        }
    }

    // Now compute the result: for each key with count > 1, add nC2
    for (i = 0; i < MAP_SIZE; i++) {
        Node *node = map_table[i];
        while (node) {
            int c = node->count;
            if (c > 1) {
                result += ((long long)c * (c - 1)) / 2;
            }
            node = node->next;
        }
    }

    return result;
}

int main() {
    int q;
    if (scanf("%d", &q) != 1) {
        return 1;
    }
    while (q--) {
        char s[101];  // per constraint length ≤100
        scanf("%s", s);
        long long ans = sherlockAndAnagrams(s);
        printf("%lld\n", ans);
    }
    return 0;
}
